<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>node系统模块 | 冰璃</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">node系统模块</h1><a id="logo" href="/.">冰璃</a><p class="description">雪肤红眸，素发如瀑</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">node系统模块</h1><div class="post-meta">Apr 15, 2019<span> | </span><span class="category"><a href="/categories/后台/">后台</a></span></div><div class="post-content"><p><strong>1.node严重依赖模块，想做什么功能都有相应的模块来配合，对模块的熟悉程度就反应了你node的熟练程度</strong></p>
<p><strong>2.node里所有api操作里都有一个sync版的同步方法，但一般不用</strong></p>
<hr>
<h3 id="常用系统模块"><a href="#常用系统模块" class="headerlink" title="常用系统模块"></a>常用系统模块</h3><ol>
<li>http<br>HTTPS<br>HTTP/2</li>
<li>断言——assert</li>
<li>fs模块</li>
<li>c++ addons (用c给node写插件以提高node性能)</li>
<li>多进程<br>child Processes<br>Cluster<br>Process</li>
<li>加密——Crypto</li>
<li>系统信息——OS</li>
<li>处理路径——path</li>
<li>事件队列——Events</li>
<li>查询字符串——Query Strings</li>
<li>网络<br>TCP——稳定，保证质量，保证顺序，保证到达。<br>UDP——快，不保证质量，不保证顺序，不保证到达。<br>NET——NET是node里实现的TCP协议。<br>UDP/Datagram——node里实现的UDP协议。</li>
<li>域名解析(把域名解析成ip地址)——DNS、domain </li>
<li>流操作——Stream</li>
<li>加密、安全——TLS/SSL (https就是基于SSL的,普通的http加上了ssl后就变成了https)</li>
<li>压缩——ZLIB(gz)</li>
</ol>
<hr>
<p><strong>http模块:</strong><br>http.createServer 创建一个服务器对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); //首先要引入http模块</span><br><span class="line"></span><br><span class="line">//创建一个服务器对象，参数是一个回调，每当有浏览器请求时，就会执行这个回调</span><br><span class="line">let server = http.createServer(()=&gt;&#123;</span><br><span class="line">  console.log(&quot;有人执行我了&quot;)</span><br><span class="line">&#125;); </span><br><span class="line">// 所有服务器都要监听端口号，包括node</span><br><span class="line">// 端口号作用是一个服务器可以运行很多程序，如果有一个客户端要连接服务器，首先得告诉服务器你连接的是哪个程序，这就靠端口号来区分了。</span><br><span class="line">// 默认端口号： http:80  ftp:21  mysql:3306 </span><br><span class="line">server.listen(8080);</span><br><span class="line">// 这时访问localhost:8080 可以看到console里打印的了</span><br></pre></td></tr></table></figure>
<p>上边的已经看到打印了，但什么都没输出，现在看一下怎么给浏览器输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); </span><br><span class="line">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class="line">    //req  请求  对服务器来说就是 接收的数据(输入)</span><br><span class="line">    //res  响应  对服务器来说接收 发送的数据(输出)</span><br><span class="line">    console.log(req.method)  // 请求的方法</span><br><span class="line">    console.log(req.url)     //请求的地址</span><br><span class="line"></span><br><span class="line">    res.write(&apos;hello world&apos;)  //写到页面</span><br><span class="line">    res.end() // 只有end了后浏览器才知道服务器输出完毕了</span><br><span class="line">&#125;); </span><br><span class="line">server.listen(8080);</span><br><span class="line">// 重启服务，再次访问可以看到页面上的hello world了</span><br></pre></td></tr></table></figure></p>
<p>目前的写到页面是死的，谁访问看到的都是hello world，我们写活一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); </span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">  fs.readFile(`www$&#123;req.url&#125;`,(err,data)=&gt;&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      res.write(&quot;404&quot;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      res.write(&quot;data&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.end()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080)</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>断言——assert</strong><br> 语法： assert(条件,”一段话”)<br> 作用：断定某个条件必须为真，如果不为真就直接把程序弄死</p>
<p><em>tips: 断言最常用的地方就是在函数里做参数的检查</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const assert=require(&quot;assert&quot;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function sum(a,b)&#123;</span><br><span class="line">  assert(arguments.length == 2,&quot;必须传2个参数&quot;);</span><br><span class="line">  assert(typeof a == &quot;number&quot;,&quot;第一个参数必须为数字&quot;);</span><br><span class="line">  assert(typeof b == &quot;number&quot;,&quot;第二个参数必须为数字&quot;);</span><br><span class="line"></span><br><span class="line">  return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(12,7)); //正常运行</span><br><span class="line">console.log(sum(2));    //直接报错  必须传2个参数</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>二进制——Buffer和File System(fs模块)</strong></p>
<p><em>Buffer是文本文件的话可以通过toString方法查看内容,其他格式toString后文件会损坏</em></p>
<p><strong>fs</strong><br>语法:<br>fs.readFile(读谁,(err,data)=&gt;{})<br>fs.writeFile(写谁,”写什么”,err=&gt;{})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  const fs=require(&apos;fs&apos;);</span><br><span class="line">  </span><br><span class="line">  //读数据</span><br><span class="line">  fs.readFile(&apos;1.txt&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&apos;读取错误&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">        //读出来的文件为Buffer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  //写数据</span><br><span class="line">  fs.writeFile(&apos;1.txt&apos;,&apos;哈哈&apos;,err=&gt;&#123;</span><br><span class="line">     if(err)&#123;</span><br><span class="line">         console.log(err)</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         console.log(&quot;写入成功&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**Crypto(加密)**</span><br><span class="line">*md5和sha1是单向散列算法，网上的破解只是通过存储最常用的md5值，查询时只是去库里找一下，这不是破解，只是库足够大*</span><br><span class="line">*绝大多数网站都没有找回密码，是因为加密后存到库里，它自己都不知道你的密码，所以大部分都只有修改密码*</span><br><span class="line">*目前应用最广泛安全的加密是**RSA(非对称加密)** *</span><br></pre></td></tr></table></figure></p>
<p> const crypto=require(“crypto”);</p>
<p> // 如果用sha1只需在这里换上sha1<br> let obj=crypto.createHash(“md5”);</p>
<p>  //直接写也行，分多次写也行<br> // obj.update(“123456”);<br> obj.update(“123”);<br> obj.update(“4”);<br> obj.update(“56”);</p>
<p> // 以16进制显示出来<br> console.log(obj.digest(“hex”))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">双层md5：</span><br></pre></td></tr></table></figure></p>
<p> const crypto=require(“crypto”);</p>
<p> function md5(str){<br> let obj=crypto.createHash(“md5”);<br> obj.update(str);<br> return obj.digest(“hex”)<br> }</p>
<p> // console.log(md5(md5(‘123456’)))<br> // 可以通过加入随机字符串来增加安全度,只要保证字符串不被人知道就可以了<br>  console.log(md5(md5(‘123456’)+’ss21f43sax’))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**Events(事件队列)**</span><br><span class="line">*Events与函数调用的最大区别在于可以解耦*</span><br></pre></td></tr></table></figure></p>
<p>  //EventEmitter翻译过来为事件触发器<br> const Event=require(‘events’).EventEmitter;<br> //new 一个事件队列对象<br> let ev=new Event();</p>
<p> //1.监听(接收)<br> ev.on(‘msg’,function(a,b,c){<br>    console.log(‘收到了msg事件’,a,b,c)<br> });</p>
<p> //2.派发(发送)<br> ev.emit(‘msg’,12,5,88)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**Query Strings**</span><br><span class="line">*解析问号后面的那一部分*</span><br></pre></td></tr></table></figure></p>
<p> const querystring=require(‘querystring’);</p>
<p> let obj=querystring.parse(一串querystring)</p>
<p> console.log(obj)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**url**</span><br><span class="line">一般url用的会比较多一点，url是解析整段url的</span><br></pre></td></tr></table></figure></p>
<p>  const url=require(‘url’);</p>
<p>   //不加true不会解析问号后面的<br>  let obj=url.parse(url,true)</p>
<p>  console.log(obj)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**DNS**</span><br><span class="line">*假设一个客户端，想访问某个网站，是分两步走的。1.把这个网站地址，解析成ip(类似120.54.26.38这种,一个地址可以有多个ip) 2.有了ip后才能根据这个ip找到对应的服务器*</span><br><span class="line"></span><br><span class="line">谁来解析这个地址？</span><br><span class="line">答案是**根DNS服务器**</span><br><span class="line">据说全世界只有五台，如果忙不过来怎么办？它下面会有一些缓存，分级的，不重要，反正是找它要ip地址，它其实就是一个超大型的数据库，里面大概就是每个域名对应的ip是多少，每个域名对应的ip是多少，这种。根dns服务器会定期广播同步给下面的分dns服务器，以便下面的分dns服务器解析</span><br></pre></td></tr></table></figure></p>
<p> // 这里的dns操作其实就是去找dns服务器，去要这个ip</p>
<p> const dns=require(‘dns’);</p>
<p> dns.resolve(‘baidu.com’,(err,res)=&gt;{<br>     if(err){<br>         console.log(‘解析失败’)<br>     }else{<br>         console.log(res)<br>     }<br> });<br><code>`</code></p>
<hr>
<p><strong>Stream</strong><br><em>连续数据都是流，视频流、网络流、文件流、语音流</em></p>
</div><div class="tags"><a href="/tags/js/">js</a></div><div class="post-nav"><a class="pre" href="/2019/04/15/进程和线程/">进程和线程</a><a class="next" href="/2019/04/15/深浅拷贝/">深浅拷贝</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'a41b62a0fd6bbf0e4420',
  clientSecret: '967058332166270e103b22da8f361fff4a9cedf9',
  repo: 'xiaohuolu.github.io',
  owner: 'xiaohuolu',
  admin: ['xiaohuolu'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台/">后台</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/h5/" style="font-size: 15px;">h5</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/进程和线程/">进程和线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/node系统模块/">node系统模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/深浅拷贝/">深浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/（通信相关）跨域、http、表单、ajax/">（通信相关）跨域、http、表单、ajax</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/ajax、promise、generator、async，await/">ajax、promise、generator、async，await</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/json、字符串、面向对象/">json、字符串、面向对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/解构、函数、扩展运算、数组/">解构、函数、扩展运算、数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/20/canvas/">canvas 基础用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/智能表单/">智能表单</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/video多浏览器支持/">video多浏览器支持</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">冰璃.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>