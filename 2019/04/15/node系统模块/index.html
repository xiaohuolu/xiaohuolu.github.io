<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>node系统模块 | 冰璃</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">node系统模块</h1><a id="logo" href="/.">冰璃</a><p class="description">雪肤红眸，素发如瀑</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">node系统模块</h1><div class="post-meta">Apr 15, 2019<span> | </span><span class="category"><a href="/categories/后台/">后台</a></span></div><div class="post-content"><p><strong>1.node严重依赖模块，想做什么功能都有相应的模块来配合，对模块的熟悉程度就反应了你node的熟练程度</strong></p>
<p><strong>2.node里所有api操作里都有一个sync版的同步方法，但一般不用</strong></p>
<hr>
<h3 id="常用系统模块"><a href="#常用系统模块" class="headerlink" title="常用系统模块"></a>常用系统模块</h3><ol>
<li>http<br>HTTPS<br>HTTP/2</li>
<li>断言——assert</li>
<li>fs模块</li>
<li>c++ addons (用c给node写插件以提高node性能)</li>
<li>多进程<br>child Processes<br>Cluster<br>Process</li>
<li>加密——Crypto</li>
<li>系统信息——OS</li>
<li>处理路径——path</li>
<li>事件队列——Events</li>
<li>查询字符串——Query Strings</li>
<li>网络<br>TCP——稳定，保证质量，保证顺序，保证到达。<br>UDP——快，不保证质量，不保证顺序，不保证到达。<br>NET——NET是node里实现的TCP协议。<br>UDP/Datagram——node里实现的UDP协议。</li>
<li>域名解析(把域名解析成ip地址)——DNS、domain </li>
<li>流操作——Stream</li>
<li>加密、安全——TLS/SSL (https就是基于SSL的,普通的http加上了ssl后就变成了https)</li>
<li>压缩——ZLIB(gz)</li>
</ol>
<hr>
<p><strong>http模块:</strong><br>http.createServer 创建一个服务器对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); //首先要引入http模块</span><br><span class="line"></span><br><span class="line">//创建一个服务器对象，参数是一个回调，每当有浏览器请求时，就会执行这个回调</span><br><span class="line">let server = http.createServer(()=&gt;&#123;</span><br><span class="line">  console.log(&quot;有人执行我了&quot;)</span><br><span class="line">&#125;); </span><br><span class="line">// 所有服务器都要监听端口号，包括node</span><br><span class="line">// 端口号作用是一个服务器可以运行很多程序，如果有一个客户端要连接服务器，首先得告诉服务器你连接的是哪个程序，这就靠端口号来区分了。</span><br><span class="line">// 默认端口号： http:80  ftp:21  mysql:3306 </span><br><span class="line">server.listen(8080);</span><br><span class="line">// 这时访问localhost:8080 可以看到console里打印的了</span><br></pre></td></tr></table></figure>
<p>上边的已经看到打印了，但什么都没输出，现在看一下怎么给浏览器输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); </span><br><span class="line">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class="line">    //req  请求  对服务器来说就是 接收的数据(输入)</span><br><span class="line">    //res  响应  对服务器来说接收 发送的数据(输出)</span><br><span class="line">    console.log(req.method)  // 请求的方法</span><br><span class="line">    console.log(req.url)     //请求的地址</span><br><span class="line"></span><br><span class="line">    res.write(&apos;hello world&apos;)  //写到页面</span><br><span class="line">    res.end() // 只有end了后浏览器才知道服务器输出完毕了</span><br><span class="line">&#125;); </span><br><span class="line">server.listen(8080);</span><br><span class="line">// 重启服务，再次访问可以看到页面上的hello world了</span><br></pre></td></tr></table></figure></p>
<p>目前的写到页面是死的，谁访问看到的都是hello world，我们写活一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); </span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">   //正确的写法应该用流，这里写法是为了理解</span><br><span class="line">  fs.readFile(`www$&#123;req.url&#125;`,(err,data)=&gt;&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      res.write(&quot;404&quot;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      res.write(&quot;data&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.end()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080)</span><br></pre></td></tr></table></figure></p>
<p>全部读取完才耗费时间和资源，正确的是加入流操作，一边读一边写入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const http=require(&apos;http&apos;);</span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">  let rs=fs.createReadStream(req.url);</span><br><span class="line"></span><br><span class="line">  rs.pipe(res);</span><br><span class="line">  </span><br><span class="line">   //处理流读取错误</span><br><span class="line">  rs.on(&apos;error&apos;,err=&gt;&#123;</span><br><span class="line">    res.writeHeader(404);</span><br><span class="line">    res.write(&apos;Not Found&apos;); </span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure></p>
<p>写入的时候加入压缩操作，减小体积<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const http=require(&apos;http&apos;);</span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line">const zlib=require(&apos;zlib&apos;);</span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">  let rs=fs.createReadStream(req.url);</span><br><span class="line">  // 这步是告诉浏览器，这是个gzip文件，需要压缩后才能用，不要当成普通文件来用。不加这步打开网页后会直接下载</span><br><span class="line">  res.setHeader(&apos;content-encoding&apos;,&apos;gzip&apos;);</span><br><span class="line">  //创建压缩对象</span><br><span class="line">  let gz=zlib.createGzip();</span><br><span class="line">  //传入gz，然后再由gz压缩后传入res</span><br><span class="line">  rs.pipe(gz).pipe(res);</span><br><span class="line"></span><br><span class="line">  res.on(&apos;error&apos;,err=&gt;&#123;</span><br><span class="line">    res.writeHeader(404);</span><br><span class="line">    res.write(&apos;Not Found&apos;);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure></p>
<p><strong>数据交互</strong><br> 获取数据,又能处理get，又能处理post<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); </span><br><span class="line">const url = require(&quot;url&quot;); </span><br><span class="line">const querystring = require(&quot;querystring&quot;); </span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">  //GET</span><br><span class="line">  let &#123;pathname,query&#125;=url.parse(req.url,true);</span><br><span class="line"></span><br><span class="line">  //POST</span><br><span class="line">  let str=&apos;&apos;</span><br><span class="line">   //有一段到达了</span><br><span class="line">  req.on(&quot;data&quot;,data=&gt;&#123;</span><br><span class="line">   str+=data</span><br><span class="line">  &#125;)</span><br><span class="line">  //结束了</span><br><span class="line">  res.on(&quot;end&quot;,()=&gt;&#123;</span><br><span class="line">   let post=querystring.parse(str)</span><br><span class="line">   console.log(post)</span><br><span class="line">  &#125;) </span><br><span class="line"></span><br><span class="line">  res.end();</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>断言——assert</strong><br> 语法： assert(条件,”一段话”)<br> 作用：断定某个条件必须为真，如果不为真就直接把程序弄死</p>
<p><em>tips: 断言最常用的地方就是在函数里做参数的检查</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const assert=require(&quot;assert&quot;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function sum(a,b)&#123;</span><br><span class="line">  assert(arguments.length == 2,&quot;必须传2个参数&quot;);</span><br><span class="line">  assert(typeof a == &quot;number&quot;,&quot;第一个参数必须为数字&quot;);</span><br><span class="line">  assert(typeof b == &quot;number&quot;,&quot;第二个参数必须为数字&quot;);</span><br><span class="line"></span><br><span class="line">  return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(12,7)); //正常运行</span><br><span class="line">console.log(sum(2));    //直接报错  必须传2个参数</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>二进制——Buffer和File System(fs模块)</strong></p>
<p><em>Buffer是文本文件的话可以通过toString方法查看内容,其他格式toString后文件会损坏</em></p>
<p><strong>fs</strong><br>语法:<br>fs.readFile(读谁,(err,data)=&gt;{})<br>fs.writeFile(写谁,”写什么”,err=&gt;{})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//读数据</span><br><span class="line">fs.readFile(&apos;1.txt&apos;,(err,data)=&gt;&#123;</span><br><span class="line">  if(err)&#123;</span><br><span class="line">      console.log(&apos;读取错误&apos;)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">      console.log(data)</span><br><span class="line">      //读出来的文件为Buffer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//写数据</span><br><span class="line">fs.writeFile(&apos;1.txt&apos;,&apos;哈哈&apos;,err=&gt;&#123;</span><br><span class="line">   if(err)&#123;</span><br><span class="line">       console.log(err)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       console.log(&quot;写入成功&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Crypto(加密)</strong><br><em>md5和sha1是单向散列算法，网上的破解只是通过存储最常用的md5值，查询时只是去库里找一下，这不是破解，只是库足够大</em><br><em>绝大多数网站都没有找回密码，是因为加密后存到库里，它自己都不知道你的密码，所以大部分都只有修改密码</em><br><em>目前应用最广泛安全的加密是<strong>RSA(非对称加密)</strong> </em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const crypto=require(&quot;crypto&quot;);</span><br><span class="line"></span><br><span class="line">// 如果用sha1只需在这里换上sha1</span><br><span class="line">let obj=crypto.createHash(&quot;md5&quot;);</span><br><span class="line"></span><br><span class="line"> //直接写也行，分多次写也行</span><br><span class="line">// obj.update(&quot;123456&quot;);</span><br><span class="line">obj.update(&quot;123&quot;);</span><br><span class="line">obj.update(&quot;4&quot;);</span><br><span class="line">obj.update(&quot;56&quot;);</span><br><span class="line"></span><br><span class="line">// 以16进制显示出来</span><br><span class="line">console.log(obj.digest(&quot;hex&quot;))</span><br></pre></td></tr></table></figure>
<p>双层md5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const crypto=require(&quot;crypto&quot;);</span><br><span class="line"></span><br><span class="line">function md5(str)&#123;</span><br><span class="line">let obj=crypto.createHash(&quot;md5&quot;);</span><br><span class="line">obj.update(str);</span><br><span class="line">return obj.digest(&quot;hex&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// console.log(md5(md5(&apos;123456&apos;)))</span><br><span class="line">// 可以通过加入随机字符串来增加安全度,只要保证字符串不被人知道就可以了</span><br><span class="line"> console.log(md5(md5(&apos;123456&apos;)+&apos;ss21f43sax&apos;))</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>Events(事件队列)</strong><br><em>Events与函数调用的最大区别在于可以解耦</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> //EventEmitter翻译过来为事件触发器</span><br><span class="line">const Event=require(&apos;events&apos;).EventEmitter;</span><br><span class="line">//new 一个事件队列对象</span><br><span class="line">let ev=new Event();</span><br><span class="line"></span><br><span class="line">//1.监听(接收)</span><br><span class="line">ev.on(&apos;msg&apos;,function(a,b,c)&#123;</span><br><span class="line">   console.log(&apos;收到了msg事件&apos;,a,b,c)</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//2.派发(发送)</span><br><span class="line">ev.emit(&apos;msg&apos;,12,5,88)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Query Strings</strong><br><em>解析问号后面的那一部分</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const querystring=require(&apos;querystring&apos;);</span><br><span class="line"> </span><br><span class="line">let obj=querystring.parse(一串querystring)</span><br><span class="line"></span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure>
<p><strong>url</strong><br>一般url用的会比较多一点，url是解析整段url的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const url=require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line"> //不加true不会解析问号后面的</span><br><span class="line">let obj=url.parse(url,true)</span><br><span class="line"></span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>DNS</strong><br><em>假设一个客户端，想访问某个网站，是分两步走的。1.把这个网站地址，解析成ip(类似120.54.26.38这种,一个地址可以有多个ip) 2.有了ip后才能根据这个ip找到对应的服务器</em></p>
<p>谁来解析这个地址？<br>答案是<strong>根DNS服务器</strong><br>据说全世界只有五台，如果忙不过来怎么办？它下面会有一些缓存，分级的，不重要，反正是找它要ip地址，它其实就是一个超大型的数据库，里面大概就是每个域名对应的ip是多少，每个域名对应的ip是多少，这种。根dns服务器会定期广播同步给下面的分dns服务器，以便下面的分dns服务器解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 这里的dns操作其实就是去找dns服务器，去要这个ip</span><br><span class="line"></span><br><span class="line">const dns=require(&apos;dns&apos;);</span><br><span class="line"></span><br><span class="line">dns.resolve(&apos;baidu.com&apos;,(err,res)=&gt;&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&apos;解析失败&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>Stream</strong><br><em>连续数据都是流，视频流、网络流、文件流、语音流</em><br>原理：<br>生产者/消费者模型</p>
<p>node中三种流:</p>
<ol>
<li>读取流   fs.createReadStream、req</li>
<li>写入流   fs.createWriteStream、res</li>
<li>读写流   压缩、加密</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">let rs=fs.createReadStream(&apos;1.png&apos;);</span><br><span class="line">let ws=fs.createWriteStream(&apos;2.png&apos;);</span><br><span class="line"></span><br><span class="line"> //管道</span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ZLIB"><a href="#ZLIB" class="headerlink" title="ZLIB"></a>ZLIB</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const zlib=require(&apos;zlib&apos;);</span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">let rs=fs.createReadStream(&apos;jquery.js&apos;);</span><br><span class="line">let ws=fs.createWriteStream(&apos;jquery.js.gz&apos;);</span><br><span class="line"> </span><br><span class="line"> //创建压缩对象</span><br><span class="line">let gz=zlib.createGzip();</span><br><span class="line"> //给压缩对象里传入东西，压缩后再传入ws里</span><br><span class="line">rs.pipe(gz).pipe(ws);</span><br><span class="line"></span><br><span class="line">ws.on(&apos;finish&apos;,()=&gt;&#123;</span><br><span class="line">  console.log(&apos;完成&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/node/">node</a></div><div class="post-nav"><a class="next" href="/2019/04/15/进程和线程/">进程和线程</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'a41b62a0fd6bbf0e4420',
  clientSecret: '967058332166270e103b22da8f361fff4a9cedf9',
  repo: 'xiaohuolu.github.io',
  owner: 'xiaohuolu',
  admin: ['xiaohuolu'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台/">后台</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/h5/" style="font-size: 15px;">h5</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/node/" style="font-size: 15px;">node</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/node系统模块/">node系统模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/进程和线程/">进程和线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/深浅拷贝/">深浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/（通信相关）跨域、http、表单、ajax/">（通信相关）跨域、http、表单、ajax</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/ajax、promise、generator、async，await/">ajax、promise、generator、async，await</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/json、字符串、面向对象/">json、字符串、面向对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/解构、函数、扩展运算、数组/">解构、函数、扩展运算、数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/20/canvas/">canvas 基础用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/智能表单/">智能表单</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/数据库/">数据库基本</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">冰璃.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>