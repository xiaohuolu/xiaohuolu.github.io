<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>node基础 | 冰璃</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">node基础</h1><a id="logo" href="/.">冰璃</a><p class="description">雪肤红眸，素发如瀑</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">node基础</h1><div class="post-meta">Apr 20, 2019<span> | </span><span class="category"><a href="/categories/后台/">后台</a></span></div><div class="post-content"><p><strong>1.node严重依赖模块，想做什么功能都有相应的模块来配合，对模块的熟悉程度就反应了你node的熟练程度</strong></p>
<p><strong>2.node里所有api操作里都有一个sync版的同步方法，但一般不用</strong></p>
<hr>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li>中间层。<ul>
<li>提高安全性</li>
<li>提高性能</li>
<li>降低主服务器复杂度</li>
</ul>
</li>
<li>小型服务</li>
<li>工具<h3 id="常用系统模块"><a href="#常用系统模块" class="headerlink" title="常用系统模块"></a>常用系统模块</h3></li>
<li>http<br>HTTPS<br>HTTP/2</li>
<li>断言——assert</li>
<li>fs模块</li>
<li>c++ addons (用c给node写插件以提高node性能)</li>
<li>多进程<br>child Processes<br>Cluster<br>Process</li>
<li>加密——Crypto</li>
<li>系统信息——OS</li>
<li>处理路径——path</li>
<li>事件队列——Events</li>
<li>查询字符串——Query Strings</li>
<li>网络<br>TCP——稳定，保证质量，保证顺序，保证到达。<br>UDP——快，不保证质量，不保证顺序，不保证到达。<br>NET——NET是node里实现的TCP协议。<br>UDP/Datagram——node里实现的UDP协议。</li>
<li>域名解析(把域名解析成ip地址)——DNS、domain </li>
<li>流操作——Stream</li>
<li>加密、安全——TLS/SSL (https就是基于SSL的,普通的http加上了ssl后就变成了https)</li>
<li>压缩——ZLIB(gz)</li>
</ol>
<hr>
<h3 id="node-js的模块系统"><a href="#node-js的模块系统" class="headerlink" title="node.js的模块系统"></a>node.js的模块系统</h3><p><strong>1.module 批量导出</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//导出json</span><br><span class="line">module.exports=&#123;</span><br><span class="line">  a:12,b:5</span><br><span class="line">&#125;</span><br><span class="line">//导出函数</span><br><span class="line">module.exports=function()&#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">//导出class</span><br><span class="line">module.exports=class &#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name=name</span><br><span class="line">  &#125;</span><br><span class="line">  show()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.exports</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exports.a=12</span><br><span class="line">exports.b=&apos;hehe&apos;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.require</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果带有路径<ul>
<li>去路径下面找</li>
</ul>
</li>
<li>如果没有路径<ul>
<li>node_modules文件夹找</li>
<li>系统的node_modules文件夹找</li>
</ul>
</li>
</ol>
<hr>
<p><strong>http模块:</strong><br>http.createServer 创建一个服务器对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); //首先要引入http模块</span><br><span class="line"></span><br><span class="line">//创建一个服务器对象，参数是一个回调，每当有浏览器请求时，就会执行这个回调</span><br><span class="line">let server = http.createServer(()=&gt;&#123;</span><br><span class="line">  console.log(&quot;有人执行我了&quot;)</span><br><span class="line">&#125;); </span><br><span class="line">// 所有服务器都要监听端口号，包括node</span><br><span class="line">// 端口号作用是一个服务器可以运行很多程序，如果有一个客户端要连接服务器，首先得告诉服务器你连接的是哪个程序，这就靠端口号来区分了。</span><br><span class="line">// 默认端口号： http:80  ftp:21  mysql:3306 </span><br><span class="line">server.listen(8080);</span><br><span class="line">// 这时访问localhost:8080 可以看到console里打印的了</span><br></pre></td></tr></table></figure>
<p>上边的已经看到打印了，但什么都没输出，现在看一下怎么给浏览器输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); </span><br><span class="line">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class="line">    //req  请求  对服务器来说就是 接收的数据(输入)</span><br><span class="line">    //res  响应  对服务器来说接收 发送的数据(输出)</span><br><span class="line">    console.log(req.method)  // 请求的方法</span><br><span class="line">    console.log(req.url)     //请求的地址</span><br><span class="line"></span><br><span class="line">    res.write(&apos;hello world&apos;)  //写到页面</span><br><span class="line">    res.end() // 只有end了后浏览器才知道服务器输出完毕了</span><br><span class="line">&#125;); </span><br><span class="line">server.listen(8080);</span><br><span class="line">// 重启服务，再次访问可以看到页面上的hello world了</span><br></pre></td></tr></table></figure></p>
<p>目前的写到页面是死的，谁访问看到的都是hello world，我们写活一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); </span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">   //正确的写法应该用流，这里写法是为了理解</span><br><span class="line">  fs.readFile(`www$&#123;req.url&#125;`,(err,data)=&gt;&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      res.write(&quot;404&quot;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      res.write(&quot;data&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.end()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080)</span><br></pre></td></tr></table></figure></p>
<p>全部读取完才耗费时间和资源，正确的是加入流操作，一边读一边写入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const http=require(&apos;http&apos;);</span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">  let rs=fs.createReadStream(req.url);</span><br><span class="line"></span><br><span class="line">  rs.pipe(res);</span><br><span class="line">  </span><br><span class="line">   //处理流读取错误</span><br><span class="line">  rs.on(&apos;error&apos;,err=&gt;&#123;</span><br><span class="line">    res.writeHeader(404);</span><br><span class="line">    res.write(&apos;Not Found&apos;); </span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure></p>
<p>写入的时候加入压缩操作，减小体积<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const http=require(&apos;http&apos;);</span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line">const zlib=require(&apos;zlib&apos;);</span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">  let rs=fs.createReadStream(req.url);</span><br><span class="line">  // 这步是告诉浏览器，这是个gzip文件，需要压缩后才能用，不要当成普通文件来用。不加这步打开网页后会直接下载</span><br><span class="line">  res.setHeader(&apos;content-encoding&apos;,&apos;gzip&apos;);</span><br><span class="line">  //创建压缩对象</span><br><span class="line">  let gz=zlib.createGzip();</span><br><span class="line">  //传入gz，然后再由gz压缩后传入res</span><br><span class="line">  rs.pipe(gz).pipe(res);</span><br><span class="line"></span><br><span class="line">  res.on(&apos;error&apos;,err=&gt;&#123;</span><br><span class="line">    res.writeHeader(404);</span><br><span class="line">    res.write(&apos;Not Found&apos;);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure></p>
<p><strong>数据交互</strong><br> 获取数据,又能处理get，又能处理post<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;); </span><br><span class="line">const url = require(&quot;url&quot;); </span><br><span class="line">const querystring = require(&quot;querystring&quot;); </span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">  //GET</span><br><span class="line">  let &#123;pathname,query&#125;=url.parse(req.url,true);</span><br><span class="line"></span><br><span class="line">  //POST</span><br><span class="line">  let arr=[]</span><br><span class="line">   //有一段到达了</span><br><span class="line">  req.on(&quot;data&quot;,data=&gt;&#123;</span><br><span class="line">   arr.push(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  //结束了</span><br><span class="line">  res.on(&quot;end&quot;,()=&gt;&#123;</span><br><span class="line">   let data=Buffer.concat(arr)</span><br><span class="line">   console.log(data)</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">  &#125;) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>断言——assert</strong><br> 语法： </p>
<ol>
<li>assert(条件,msg)<br>作用：断定某个条件必须为真，如果不为真就直接把程序弄死</li>
<li>assert.deepEqual(变量,预期值,msg)<br>作用：深度比较，比方说两个数组，我不仅要它们都是数组，我还要他们里面的成员也一样，相当于js里的双等。</li>
<li>assert.deepStrictEqual(变量,预期值,msg)<br>作用：相当于三等，不光比较成员，还会比较类型。</li>
</ol>
<p><em>tips: 断言最常用的地方就是在函数里做参数的检查</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const assert=require(&quot;assert&quot;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function sum(a,b)&#123;</span><br><span class="line">  assert(arguments.length == 2,&quot;必须传2个参数&quot;);</span><br><span class="line">  assert(typeof a == &quot;number&quot;,&quot;第一个参数必须为数字&quot;);</span><br><span class="line">  assert(typeof b == &quot;number&quot;,&quot;第二个参数必须为数字&quot;);</span><br><span class="line"></span><br><span class="line">  return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(12,7)); //正常运行</span><br><span class="line">console.log(sum(2));    //直接报错  必须传2个参数</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>File System(fs模块)和二进制——Buffer</strong></p>
<p><em>Buffer是文本文件的话可以通过toString方法查看内容,其他格式toString后文件会损坏</em></p>
<p><strong>fs</strong><br>语法:<br>fs.readFile(读谁,(err,data)=&gt;{})<br>fs.writeFile(写谁,”写什么”,err=&gt;{})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//读数据</span><br><span class="line">fs.readFile(&apos;1.txt&apos;,(err,data)=&gt;&#123;</span><br><span class="line">  if(err)&#123;</span><br><span class="line">      console.log(&apos;读取错误&apos;)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">      console.log(data)</span><br><span class="line">      //读出来的文件为Buffer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//写数据</span><br><span class="line">fs.writeFile(&apos;1.txt&apos;,&apos;哈哈&apos;,err=&gt;&#123;</span><br><span class="line">   if(err)&#123;</span><br><span class="line">       console.log(err)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       console.log(&quot;写入成功&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>buffer处理</strong><br>文件上传 node原生处理:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">const http=require(&apos;http&apos;);</span><br><span class="line">const common=require(&apos;./libs/common&apos;);</span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">let server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">  let arr=[];</span><br><span class="line"></span><br><span class="line">  req.on(&apos;data&apos;,data=&gt;&#123;</span><br><span class="line">    arr.push(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  req.end(&apos;end&apos;,()=&gt;&#123;</span><br><span class="line">    let data=Buffer.concat(arr);</span><br><span class="line">    </span><br><span class="line">    //准备两个容器</span><br><span class="line">    let post=&#123;&#125;;  //装普通数据</span><br><span class="line">    let files=&#123;&#125;; //装文件数据</span><br><span class="line">    //解析二进制文件上传的数据</span><br><span class="line">    //怎么知道是不是文件上传 可以从req.headers里的content-type里判断类型</span><br><span class="line">      //如果有东西说明是文件上传 </span><br><span class="line">   if(req.headers[&apos;content-type&apos;])&#123;</span><br><span class="line">    let str=req.headers[&apos;content-type&apos;].split(&apos;; &apos;)[1];</span><br><span class="line"></span><br><span class="line">     if(str)&#123;</span><br><span class="line">       let boundary=&apos;--&apos;+str.split(&apos;=&apos;)[1];</span><br><span class="line"></span><br><span class="line">       // 1.用分隔符来切分整个数据</span><br><span class="line">        data.split(boundary);</span><br><span class="line">      </span><br><span class="line">       // 2. 丢弃头尾的无用数据</span><br><span class="line">        arr.shift();</span><br><span class="line">        arr.pop();</span><br><span class="line">       </span><br><span class="line">       // 3. 丢弃掉每个头尾的\r\n</span><br><span class="line">       arr=arr.map(buffer=&gt;buffer.slice(2,buffer.length-2));</span><br><span class="line"></span><br><span class="line">       // 4. 每个数据在第一个\r\n\r\n处切成两半，一半是描述部分，一半是值的部分</span><br><span class="line">       arr.forEach(buffer=&gt;&#123;</span><br><span class="line">         let n=buffer.indexOf(&apos;\r\n\r\n&apos;);</span><br><span class="line"> </span><br><span class="line">         //描述部分</span><br><span class="line">         let disposition=buffer.slice(0,n);</span><br><span class="line">         //内容部分</span><br><span class="line">         let content=buffer.slice(n+4);</span><br><span class="line">         </span><br><span class="line">         //描述部分肯定是文字，所以可以toString</span><br><span class="line">         disposition=disposition.toString();</span><br><span class="line"></span><br><span class="line">          // ==-1说明只有一行描述</span><br><span class="line">         if(disposition.indexOf(&apos;\r\n&apos;)==-1)&#123;</span><br><span class="line">            //普通数据</span><br><span class="line">            //Content-Disposition:form-data; name=&apos;user&apos;</span><br><span class="line"></span><br><span class="line">            content=content.toString();</span><br><span class="line">            //取name</span><br><span class="line">            let name=disposition.split(&apos;; &apos;)[1].split(&apos;=&apos;)[1];</span><br><span class="line">            //去掉name分号</span><br><span class="line">            name=name.substring(1,name.length-1);</span><br><span class="line"></span><br><span class="line">            post[name]=content;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">            //文件数据</span><br><span class="line">            /*Content-Disposition:form-data; name=&apos;f1&apos;; filename=&apos;a.txt&apos;\r\n Content-type:text/plain*/</span><br><span class="line"></span><br><span class="line">            let [line1,line2]=disposition.split(&apos;\r\n&apos;); </span><br><span class="line">            let [,name,filename]=line1.split(&apos;; &apos;);</span><br><span class="line">            let type=line2.split(&apos;: &apos;)[1];</span><br><span class="line"></span><br><span class="line">            name=name.split(&apos;=&apos;)[1];</span><br><span class="line">            name=name.substring(1,name.length-1);</span><br><span class="line"></span><br><span class="line">            filename=filename.split(&apos;=&apos;)[1];</span><br><span class="line">            filename=filename.substring(1,filename.length-1);</span><br><span class="line"></span><br><span class="line">            fs.writeFile(&apos;&apos;)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    res.end();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(8080)</span><br></pre></td></tr></table></figure></p>
<p>文件上传：node模块multiparty处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const multiparty = require(&apos;multiparty&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer((req,res)=&gt;&#123;</span><br><span class="line">    let form=new multiparty.form(&#123;</span><br><span class="line">        uploadDir:&apos;./upload&apos;  //上传到哪</span><br><span class="line">    &#125;)</span><br><span class="line">    form.parse(req);</span><br><span class="line"></span><br><span class="line">    form.on(&apos;field&apos;,(name,value)=&gt;&#123;</span><br><span class="line">        console.log(name,value);</span><br><span class="line">    &#125;)</span><br><span class="line">    form.on(&apos;file&apos;,(name,file)=&gt;&#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">        console.log(file)</span><br><span class="line">    &#125;)</span><br><span class="line">    form.on(&apos;close&apos;,()=&gt;&#123;</span><br><span class="line">        console.log(&apos;表单解析完成&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>Crypto加密</strong><br><em>md5和sha1是单向散列算法，网上的破解只是通过存储最常用的md5值，查询时只是去库里找一下，这不是破解，只是库足够大</em><br><em>绝大多数网站都没有找回密码，是因为加密后存到库里，它自己都不知道你的密码，所以大部分都只有修改密码</em><br><em>目前应用最广泛安全的加密是<strong>RSA(非对称加密)</strong></em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const crypto=require(&quot;crypto&quot;);</span><br><span class="line"></span><br><span class="line">// 如果用sha1只需在这里换上sha1</span><br><span class="line">let obj=crypto.createHash(&quot;md5&quot;);</span><br><span class="line"></span><br><span class="line"> //直接写也行，分多次写也行</span><br><span class="line">// obj.update(&quot;123456&quot;);</span><br><span class="line">obj.update(&quot;123&quot;);</span><br><span class="line">obj.update(&quot;4&quot;);</span><br><span class="line">obj.update(&quot;56&quot;);</span><br><span class="line"></span><br><span class="line">// 以16进制显示出来</span><br><span class="line">console.log(obj.digest(&quot;hex&quot;))</span><br></pre></td></tr></table></figure>
<p>双层md5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const crypto=require(&quot;crypto&quot;);</span><br><span class="line"></span><br><span class="line">function md5(str)&#123;</span><br><span class="line">let obj=crypto.createHash(&quot;md5&quot;);</span><br><span class="line">obj.update(str);</span><br><span class="line">return obj.digest(&quot;hex&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// console.log(md5(md5(&apos;123456&apos;)))</span><br><span class="line">// 可以通过加入随机字符串来增加安全度,只要保证字符串不被人知道就可以了</span><br><span class="line"> console.log(md5(md5(&apos;123456&apos;)+&apos;ss21f43sax&apos;))</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>常用方法：</p>
<ol>
<li>path.dirname(str)  目录名</li>
<li>path.extname(str)  扩展名</li>
<li>path.basename(str) 文件名</li>
<li>path.resolve(‘/root/a/b’,’../c’,’build’,’..’,’strict’)             路径拼接，解析出来绝对路径<br>解释：root/a/b下，返回上一级进入c,找build,返回上一级，找strict。console出来的路径就是/root/a/c/strict。(<strong>dirname被称为魔术变量，不需要声明，是由编译器给的一个地址，在不同文件里值不一样，指的就是当前目录)<br>常用：当需要当前目录的绝对路径的时候，就需要这个。path.resolve(</strong>dirname,文件);</li>
</ol>
<hr>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>如果开发环境是Windows，生产环境是linux，可以用这种方法判断开发环境和生产环境：</p>
<p><em>取得process.env.OS的值，通过判断是不是Window_NT，来确定是开发环境还是生产环境,true就是dev</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const process = require(&apos;process&apos;);</span><br></pre></td></tr></table></figure>
<p><strong>Events事件队列</strong><br><em>Events与函数调用的最大区别在于可以解耦</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> //EventEmitter翻译过来为事件触发器</span><br><span class="line">const Event=require(&apos;events&apos;).EventEmitter;</span><br><span class="line">//new 一个事件队列对象</span><br><span class="line">let ev=new Event();</span><br><span class="line"></span><br><span class="line">//1.监听(接收)</span><br><span class="line">ev.on(&apos;msg&apos;,function(a,b,c)&#123;</span><br><span class="line">   console.log(&apos;收到了msg事件&apos;,a,b,c)</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//2.派发(发送)</span><br><span class="line">ev.emit(&apos;msg&apos;,12,5,88)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Query Strings</strong><br><em>解析问号后面的那一部分</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const querystring=require(&apos;querystring&apos;);</span><br><span class="line"> </span><br><span class="line">let obj=querystring.parse(一串querystring)</span><br><span class="line"></span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure>
<p><strong>url</strong><br>一般url用的会比较多一点，url是解析整段url的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const url=require(url);</span><br><span class="line"></span><br><span class="line"> // 加true会把query解析成json</span><br><span class="line">let obj=url.parse(url,true)</span><br><span class="line"></span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>DNS</strong><br><em>假设一个客户端，想访问某个网站，是分两步走的。1.把这个网站地址，解析成ip(类似120.54.26.38这种,一个地址可以有多个ip) 2.有了ip后才能根据这个ip找到对应的服务器</em></p>
<p>谁来解析这个地址？<br>答案是<strong>根DNS服务器</strong><br>据说全世界只有五台，如果忙不过来怎么办？它下面会有一些缓存，分级的，不重要，反正是找它要ip地址，它其实就是一个超大型的数据库，里面大概就是每个域名对应的ip是多少，每个域名对应的ip是多少，这种。根dns服务器会定期广播同步给下面的分dns服务器，以便下面的分dns服务器解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 这里的dns操作其实就是去找dns服务器，去要这个ip</span><br><span class="line"></span><br><span class="line">const dns=require(&apos;dns&apos;);</span><br><span class="line"></span><br><span class="line">dns.resolve(&apos;baidu.com&apos;,(err,res)=&gt;&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&apos;解析失败&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>Stream</strong><br><em>连续数据都是流，视频流、网络流、文件流、语音流</em><br>原理：<br>生产者/消费者模式</p>
<p>node中三种流:</p>
<ol>
<li>读取流   fs.createReadStream、req</li>
<li>写入流   fs.createWriteStream、res</li>
<li>读写流   压缩、加密</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">let rs=fs.createReadStream(&apos;1.png&apos;);</span><br><span class="line">let ws=fs.createWriteStream(&apos;2.png&apos;);</span><br><span class="line"></span><br><span class="line"> //管道</span><br><span class="line">rs.pipe(ws)</span><br><span class="line"></span><br><span class="line">rs.on(&apos;error&apos;,err=&gt;&#123;</span><br><span class="line">  console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.on(&apos;finish&apos;,()=&gt;&#123;</span><br><span class="line">  console.log(&apos;完成&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ZLIB压缩"><a href="#ZLIB压缩" class="headerlink" title="ZLIB压缩"></a>ZLIB压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const zlib=require(&apos;zlib&apos;);</span><br><span class="line">const fs=require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">let rs=fs.createReadStream(&apos;jquery.js&apos;);</span><br><span class="line">let ws=fs.createWriteStream(&apos;jquery.js.gz&apos;);</span><br><span class="line"> </span><br><span class="line"> //创建压缩对象</span><br><span class="line">let gz=zlib.createGzip();</span><br><span class="line"> //给压缩对象里传入东西，压缩后再传入ws里</span><br><span class="line">rs.pipe(gz).pipe(ws);</span><br><span class="line"></span><br><span class="line">ws.on(&apos;finish&apos;,()=&gt;&#123;</span><br><span class="line">  console.log(&apos;完成&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>缓存实现过程</strong><br>C客户端<br>S服务端</p>
<p>第一次：<br>请求的时候S需要告诉C一个 Last-Modified:Sat,02 Dec 2017 04:03:14 GMT(文件修改的日期)<br>第二次：<br>1.C-&gt;S: If-Modified-Since: Sat,02 Dec 2017 04:03:14 GMT （文件最后修改的时间）<br>2.S-&gt;C: 200 || 304</p>
<p>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const url = require(&apos;url&apos;); // 有可能有数据有可能没数据，需要url解析一下</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) =&gt; &#123;</span><br><span class="line">    let &#123; pathname &#125; = url.parse(req.url);</span><br><span class="line">    //获取文件日期</span><br><span class="line">    fs.stat(`www$&#123;pathname&#125;`, (err, stat) =&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            res.writeHeader(404);</span><br><span class="line">            res.write(&apos;Not Found&apos;);</span><br><span class="line">            res.end()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (req.headers[&apos;if-modified-since&apos;]) &#123;</span><br><span class="line">                let oDate = new Date(req.headers[&apos;if-modified-since&apos;]);</span><br><span class="line">                let time_client = Math.floor(oDate.getTime() / 1000); //客户端时间</span><br><span class="line"></span><br><span class="line">                let time_server = Math.floor(stat.mtime.getTime() / 1000); //服务端时间</span><br><span class="line">                </span><br><span class="line">                if(time_server&gt;time_client)&#123;         //服务器的文件时间大于客户端手里的版本，说明服务器的比较新，就直接发送</span><br><span class="line">                    sendFileToClient()    </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res.writeHeader(304);</span><br><span class="line">                    res.write(&apos;Not Modified&apos;);</span><br><span class="line">                    res.end();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sendFileToClient();</span><br><span class="line">            &#125;</span><br><span class="line">            function sendFileToClient() &#123;</span><br><span class="line">                let rs = fs.createReadStream(`www$&#123;pathname&#125;`);</span><br><span class="line">              </span><br><span class="line">                res.setHeader(&apos;Last-Modified&apos;, stat.mtime.toGMTString());</span><br><span class="line">                //输出</span><br><span class="line">                rs.pipe(res);</span><br><span class="line"></span><br><span class="line">                res.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class="line">                    res.writeHeader(404);</span><br><span class="line">                    res.write(&apos;Not Found&apos;);</span><br><span class="line">                    res.end()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;).listen(8080);</span><br><span class="line"></span><br><span class="line">    //  stat对象</span><br><span class="line"></span><br><span class="line">    // dev: 16777218,                               设备号</span><br><span class="line">    // mode: 33188,                                 模式</span><br><span class="line">    // nlink: 1,                                    连接数</span><br><span class="line">    // uid: 501,</span><br><span class="line">    // gid: 20,</span><br><span class="line">    // rdev: 0,</span><br><span class="line">    // blksize: 4096,</span><br><span class="line">    // ino: 5220372,</span><br><span class="line">    // size: 277,                                   大小</span><br><span class="line">    // blocks: 8,</span><br><span class="line">    // atimeMs: 1555987201000,</span><br><span class="line">    // mtimeMs: 1555985692000,                      </span><br><span class="line">    // ctimeMs: 1555985692000,</span><br><span class="line">    // birthtimeMs: 1555984506000,</span><br><span class="line">    // atime: 2019-04-23T02:40:01.000Z,</span><br><span class="line">    // mtime: 2019-04-23T02:14:52.000Z,             修改时间Modified-time</span><br><span class="line">    // ctime: 2019-04-23T02:14:52.000Z,</span><br><span class="line">    // birthtime: 2019-04-23T01:55:06.000Z &#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/node/">node</a></div><div class="post-nav"><a class="pre" href="/2019/04/22/正则表达式/">正则表达式</a><a class="next" href="/2019/04/19/进程和线程/">进程和线程</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'a41b62a0fd6bbf0e4420',
  clientSecret: '967058332166270e103b22da8f361fff4a9cedf9',
  repo: 'xiaohuolu.github.io',
  owner: 'xiaohuolu',
  admin: ['xiaohuolu'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台/">后台</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目管理/">项目管理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/h5/" style="font-size: 15px;">h5</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/utils/" style="font-size: 15px;">utils</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/git/" style="font-size: 15px;">git</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/10/27/权限控制/">权限控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/27/注册用户/">注册用户</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/27/验证身份/">验证身份</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/27/用户登录/">用户登录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/27/存储内容/">存储内容</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/26/数据仓库/">数据仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/26/数据连接/">数据连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/20/mysql-Access-denied-for-user-root-localhost-using-passwordYES-问题/">mysql Access denied for user root@localhost (using passwordYES)问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/20/设计架构/">设计架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/14/在node项目中使用typescript/">在node项目中使用typescript</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">冰璃.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>